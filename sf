针对不同团队需要不同凭证的需求，我们可以通过扩展配置来实现。以下是分步解决方案：

---

### 步骤1：增强配置结构
在`application.yml`中配置团队专属信息：
```yaml
teams:
  configs:
    teamA:
      base-url: https://api.team-a.com
      credentials:
        username: teamA_user
        password: s3cr3tA
    teamB:
      base-url: https://api.team-b.com
      credentials:
        username: teamB_user
        password: s3cr3tB
```

---

### 步骤2：创建配置实体类
```java
@Configuration
@ConfigurationProperties(prefix = "teams")
public class TeamConfig {
    private Map<String, TeamClientConfig> configs = new HashMap<>();

    @Data
    public static class TeamClientConfig {
        private String baseUrl;
        private Credentials credentials;
        
        @Data
        public static class Credentials {
            private String username;
            private String password;
        }
    }

    // Getter/Setter
    public Map<String, TeamClientConfig> getConfigs() {
        return configs;
    }

    public void setConfigs(Map<String, TeamClientConfig> configs) {
        this.configs = configs;
    }
}
```

---

### 步骤3：改造API接口
```java
public interface ThirdPartyApiClient {
    // 移除固定参数，改为从上下文获取
    @PostExchange(url = "/auth/token", contentType = "application/x-www-form-urlencoded")
    Mono<TokenResponse> fetchToken();
}
```

---

### 步骤4：实现凭证拦截器
```java
public class CredentialInterceptor implements ExchangeFilterFunction {
    private final String username;
    private final password;

    public CredentialInterceptor(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @Override
    public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {
        if (request.url().getPath().contains("/auth/token")) {
            String credentials = "username=" + username + "&password=" + password;
            return next.exchange(ClientRequest.from(request)
                .body(credentials, MediaType.APPLICATION_FORM_URLENCODED)
                .build());
        }
        return next.exchange(request);
    }
}
```

---

### 步骤5：增强客户端工厂
```java
@Component
public class TeamApiClientFactory {
    private final Map<String, ThirdPartyApiClient> clientCache = new ConcurrentHashMap<>();
    private final TeamConfig teamConfig;
    private final HttpServiceProxyFactory.Builder factoryBuilder;

    public TeamApiClientFactory(
        TeamConfig teamConfig,
        WebClient.Builder webClientBuilder
    ) {
        this.teamConfig = teamConfig;
        this.factoryBuilder = HttpServiceProxyFactory.builder()
            .exchangeAdapter(WebClientAdapter.forBuilder(webClientBuilder));
    }

    public ThirdPartyApiClient getClient(String teamName) {
        return clientCache.computeIfAbsent(teamName, name -> {
            TeamConfig.TeamClientConfig config = teamConfig.getConfigs().get(name);
            validateConfig(name, config);

            WebClient customClient = buildTeamWebClient(config);
            return factoryBuilder.build().createClient(ThirdPartyApiClient.class, customClient);
        });
    }

    private WebClient buildTeamWebClient(TeamConfig.TeamClientConfig config) {
        return WebClient.builder()
            .baseUrl(config.getBaseUrl())
            .filter(new CredentialInterceptor(
                config.getCredentials().getUsername(),
                config.getCredentials().getPassword()
            ))
            .build();
    }

    private void validateConfig(String teamName, TeamConfig.TeamClientConfig config) {
        if (config == null) {
            throw new IllegalArgumentException("未配置的团队: " + teamName);
        }
        if (config.getCredentials() == null) {
            throw new ConfigurationException(teamName + "缺少凭证配置");
        }
    }
}
```

---

### 步骤6：服务层调整
```java
@Service
public class TransactionalDataService {
    private final TeamApiClientFactory apiClientFactory;

    public Mono<Void> processData(String teamName, List<ByteArrayResource> files) {
        ThirdPartyApiClient client = apiClientFactory.getClient(teamName);

        return client.fetchToken()
            .flatMap(token -> {
                String authHeader = "Bearer " + token.token();
                return client.createTransaction(authHeader)
                    .flatMap(tx -> processTransaction(client, authHeader, tx.id(), files));
            });
    }

    private Mono<Void> processTransaction(
        ThirdPartyApiClient client,
        String authHeader,
        String txId,
        List<ByteArrayResource> files
    ) {
        return Flux.fromIterable(files)
            .flatMap(file -> client.commit(txId, authHeader, file))
            .then(client.closeTransaction(txId, authHeader))
            .onErrorResume(e -> 
                client.rollback(txId, authHeader)
                    .then(Mono.error(e))
            );
    }
}
```

---

### 实现要点说明：

1. **动态凭证注入**：
   - 通过`CredentialInterceptor`自动注入团队专属凭证
   - Token请求不再需要显式传递用户名密码

2. **安全配置**：
   ```java
   // 拦截器自动处理敏感凭证
   .filter(new CredentialInterceptor(username, password))
   ```
   避免在代码中明文出现凭证信息

3. **配置验证**：
   ```java
   private void validateConfig(...) {
       // 启动时检查配置完整性
   }
   ```
   确保所有必需配置项都存在

4. **接口简化**：
   ```java
   Mono<TokenResponse> fetchToken(); // 无需参数
   ```
   调用方无需关心凭证传递细节

---

### 高级安全方案（可选）：

如果需要更高安全性，可以采用以下改进：

1. **加密存储密码**：
   ```yaml
   teams:
     configs:
       teamA:
         credentials:
           username: teamA_user
           password: "{cipher}encrypted_string_here"
   ```

2. **使用Vault集成**：
   ```java
   public class VaultCredentialProvider {
       public Credentials getCredentials(String teamName) {
           // 从Vault获取动态凭证
       }
   }
   ```

3. **临时令牌机制**：
   ```java
   .filter((request, next) -> {
       return getTempToken()
           .flatMap(token -> 
               next.exchange(withAuthHeader(request, token))
           );
   })
   ```

---

### 最终架构优势：
1. **完全解耦**：服务层完全不需要知道凭证细节
2. **配置集中管理**：所有团队配置统一维护
3. **自动凭证轮换**：通过拦截器机制可轻松实现凭证更新
4. **类型安全**：所有配置访问都通过类型化的配置类
5. **可观测性**：可在拦截器中统一添加日志/监控

这种设计既保持了接口的简洁性，又实现了敏感信息的隔离管理，是处理多租户系统凭证差异的理想方案。