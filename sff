为了解决这个问题，我们需要将包含文件路径的实体列表按照文件大小进行分组，确保每组文件的总大小不超过100MB，同时处理单个文件超过100MB的情况。以下是详细的解决方案：

### 方法思路
1. **初始化**：创建结果列表和临时列表来存储当前分组的实体和累计大小。
2. **遍历实体列表**：对于每个实体，获取其文件大小。
3. **处理大文件**：如果文件大小超过100MB，确保当前分组（如果有）被添加到结果中，然后将该大文件单独作为一组添加到结果中。
4. **处理小文件**：如果文件大小未超过100MB，检查将其添加到当前分组是否会超过100MB。如果是，则将当前分组添加到结果中并新建分组；否则，将其添加到当前分组并更新累计大小。
5. **处理剩余文件**：遍历结束后，将剩余的实体（如果有）作为最后一组添加到结果中。

### 解决代码
```java
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class GroupingService {

    private static final long MB_100 = 100L * 1024 * 1024;

    public List<List<Entity>> groupEntities(List<Entity> entityList) {
        List<List<Entity>> result = new ArrayList<>();
        List<Entity> currentGroup = new ArrayList<>();
        long currentGroupSize = 0;

        for (Entity entity : entityList) {
            File file = new File(entity.getFilePath());
            long fileSize = file.length();

            if (fileSize >= MB_100) {
                if (!currentGroup.isEmpty()) {
                    result.add(currentGroup);
                    currentGroup = new ArrayList<>();
                    currentGroupSize = 0;
                }
                List<Entity> singleGroup = new ArrayList<>();
                singleGroup.add(entity);
                result.add(singleGroup);
            } else {
                if (currentGroupSize + fileSize >= MB_100) {
                    result.add(currentGroup);
                    currentGroup = new ArrayList<>();
                    currentGroup.add(entity);
                    currentGroupSize = fileSize;
                } else {
                    currentGroup.add(entity);
                    currentGroupSize += fileSize;
                }
            }
        }

        if (!currentGroup.isEmpty()) {
            result.add(currentGroup);
        }

        return result;
    }

    public static class Entity {
        private String filePath;

        public Entity(String filePath) {
            this.filePath = filePath;
        }

        public String getFilePath() {
            return filePath;
        }

        public void setFilePath(String filePath) {
            this.filePath = filePath;
        }
    }
}
```

### 代码解释
1. **常量定义**：`MB_100`常量表示100MB的字节数，用于比较文件大小。
2. **分组逻辑**：
   - **大文件处理**：当文件大小超过100MB时，当前分组（如果有）被添加到结果中，然后该大文件单独成组添加到结果中。
   - **小文件处理**：检查当前分组累计大小加上当前文件大小是否超过100MB。如果是，则当前分组添加到结果中，并新建分组；否则，将文件添加到当前分组并更新累计大小。
3. **剩余处理**：遍历结束后，确保最后的分组（如果有）被添加到结果中。

这种方法确保文件被合理分组，满足每组总大小不超过100MB的要求，同时处理了大文件单独成组的情况。