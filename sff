在Spring Boot全局异常处理器中获取请求头中的request id，有以下几种实现方式：

1. 通过 HttpServletRequest 获取（推荐）

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(
            Exception ex, 
            HttpServletRequest request) {
        
        // 从请求头中获取 request id
        String requestId = request.getHeader("X-Request-ID");
        // 或者使用其他常见的 header 名称
        // String requestId = request.getHeader("X-Request-Id");
        // String requestId = request.getHeader("requestId");
        
        // 如果没有传递，可以生成一个默认的
        if (StringUtils.isEmpty(requestId)) {
            requestId = UUID.randomUUID().toString();
        }
        
        // 记录日志，包含 request id
        log.error("Request ID: {}, Error: {}", requestId, ex.getMessage(), ex);
        
        // 返回响应
        ErrorResponse error = ErrorResponse.builder()
                .requestId(requestId)
                .timestamp(LocalDateTime.now())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(error);
    }
}


2. 通过 @RequestHeader 注解获取

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(
            Exception ex,
            @RequestHeader(value = "X-Request-ID", required = false) String requestId,
            HttpServletRequest request) {
        
        if (StringUtils.isEmpty(requestId)) {
            requestId = generateRequestId();
        }
        
        // 处理异常...
        return buildErrorResponse(ex, requestId, request);
    }
}


3. 通过 RequestContextHolder 获取（线程安全）

@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {
        
        // 从当前请求上下文中获取
        ServletRequestAttributes attributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        
        if (attributes != null) {
            HttpServletRequest request = attributes.getRequest();
            String requestId = request.getHeader("X-Request-ID");
            
            // 处理异常...
        }
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
    }
}


4. 完整示例：带有日志追踪的全局异常处理

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // 处理所有异常
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiError> handleAllExceptions(
            Exception ex, 
            WebRequest request) {
        
        // 获取 request id
        String requestId = ((ServletRequestAttributes) 
                RequestContextHolder.currentRequestAttributes())
                .getRequest()
                .getHeader("X-Request-ID");
        
        // 如果没有，从 MDC 中获取（如果使用了日志框架）
        if (StringUtils.isEmpty(requestId)) {
            requestId = MDC.get("requestId");
        }
        
        // 如果还是没有，生成一个
        if (StringUtils.isEmpty(requestId)) {
            requestId = UUID.randomUUID().toString().substring(0, 8);
        }
        
        // 记录带 request id 的日志
        log.error("[RequestId: {}] 系统异常: {}", requestId, ex.getMessage(), ex);
        
        // 构建错误响应
        ApiError apiError = ApiError.builder()
                .requestId(requestId)
                .timestamp(Instant.now())
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .error("Internal Server Error")
                .message("系统繁忙，请稍后重试")
                .path(((ServletWebRequest) request).getRequest().getRequestURI())
                .build();
        
        return new ResponseEntity<>(apiError, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiError> handleBusinessException(
            BusinessException ex, 
            HttpServletRequest request) {
        
        String requestId = request.getHeader("X-Request-ID");
        
        log.warn("[RequestId: {}] 业务异常: {}", requestId, ex.getMessage());
        
        ApiError apiError = ApiError.builder()
                .requestId(requestId)
                .timestamp(Instant.now())
                .status(ex.getCode())
                .error("Business Error")
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }
}

// 错误响应 DTO
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
class ApiError {
    private String requestId;
    private Instant timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
}


5. 使用 Filter 或 Interceptor 预先处理 request id

@Component
public class RequestIdFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(
            HttpServletRequest request, 
            HttpServletResponse response, 
            FilterChain filterChain) throws ServletException, IOException {
        
        // 获取或生成 request id
        String requestId = request.getHeader("X-Request-ID");
        if (StringUtils.isEmpty(requestId)) {
            requestId = UUID.randomUUID().toString();
        }
        
        // 设置到请求属性中，方便后续获取
        request.setAttribute("requestId", requestId);
        
        // 设置到响应头
        response.setHeader("X-Request-ID", requestId);
        
        // 设置到 MDC，用于日志追踪
        MDC.put("requestId", requestId);
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            // 清除 MDC
            MDC.clear();
        }
    }
}


// 异常处理器中从请求属性获取
@ExceptionHandler(Exception.class)
public ResponseEntity<ApiError> handleException(
        Exception ex, 
        HttpServletRequest request) {
    
    String requestId = (String) request.getAttribute("requestId");
    // ...
}


6. 使用 Spring Cloud Sleuth（分布式追踪）

如果使用微服务架构，建议使用 Sleuth 自动生成 traceId：

# application.yml
spring:
  sleuth:
    enabled: true


@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(Exception ex) {
    // 自动注入 TraceId
    String traceId = org.slf4j.MDC.get("traceId");
    
    log.error("TraceId: {}, Error: {}", traceId, ex.getMessage(), ex);
    
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .header("X-Trace-Id", traceId)
            .body(new ErrorResponse(traceId, ex.getMessage()));
}


最佳实践建议：

1. 统一命名：团队内统一定义 request id 的 header 名称，如 X-Request-ID

2. 客户端传递：建议前端/客户端在请求时自动生成并传递 request id

3. 服务端兜底：如果客户端未传递，服务端应自动生成

4. 日志关联：将 request id 记录到所有相关日志中，便于问题追踪

5. 响应头返回：在响应头中也返回 request id，方便客户端调试

6. 异步处理：如果是异步处理，需要手动传递 request id 到子线程

这样配置后，无论系统哪个地方发生异常，都能在全局异常处理器中获取到 request id，便于问题排查和日志追踪。