在Spring Boot中整合Prometheus并自定义指标记录用户查询的JSON和查询时间，可以通过以下步骤实现。这里使用Micrometer作为指标收集库，它是Spring Boot Actuator的默认指标工具。

---

### 1. 添加依赖
在`pom.xml`中添加依赖：
```xml
<dependencies>
    <!-- Spring Boot Actuator + Prometheus -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
</dependencies>
```

---

### 2. 配置Prometheus端点
在`application.properties`中启用Prometheus端点：
```properties
# 暴露Prometheus指标端点
management.endpoints.web.exposure.include=prometheus
# 启用指标自动配置
management.metrics.enable.all=true
```

---

### 3. 自定义指标记录查询信息
#### 方案一：使用AOP拦截查询请求（推荐）
**步骤：**
1. 创建自定义注解`@TrackQuery`
2. 实现AOP切面记录指标
3. 在Controller方法上添加注解

**代码实现：**

##### (1) 创建注解
```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TrackQuery {}
```

##### (2) 实现AOP切面
```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.util.StopWatch;

import java.util.concurrent.TimeUnit;

@Aspect
@Component
public class QueryMetricsAspect {

    private final MeterRegistry meterRegistry;

    public QueryMetricsAspect(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    @Around("@annotation(TrackQuery)")
    public Object trackQuery(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取查询JSON参数（假设第一个参数是JSON字符串）
        String queryJson = (String) joinPoint.getArgs()[0];
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        try {
            return joinPoint.proceed();
        } finally {
            stopWatch.stop();
            long duration = stopWatch.getTotalTimeMillis();
            
            // 记录查询时间
            Timer.builder("user.query.timer")
                .tags("query", queryJson)  // 注意：高基数标签需谨慎使用
                .register(meterRegistry)
                .record(duration, TimeUnit.MILLISECONDS);
            
            // 记录查询次数
            meterRegistry.counter("user.query.counter", "query", queryJson).increment();
        }
    }
}
```

##### (3) 在Controller中使用
```java
@RestController
public class QueryController {
    
    @PostMapping("/query")
    @TrackQuery // 添加自定义注解
    public ResponseEntity<?> executeQuery(@RequestBody String queryJson) {
        // 处理查询逻辑
        return ResponseEntity.ok().build();
    }
}
```

---

#### 方案二：手动注册指标（直接使用MeterRegistry）
在Service中直接注入`MeterRegistry`：

```java
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Service;

@Service
public class QueryService {
    
    private final MeterRegistry meterRegistry;
    
    public QueryService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void processQuery(String queryJson) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 执行查询逻辑...
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            
            // 记录指标
            Timer.builder("user.query.timer")
                .tags("query", queryJson)
                .register(meterRegistry)
                .record(duration, TimeUnit.MILLISECONDS);
        }
    }
}
```

---

### 4. 处理高基数标签问题
**注意：** 直接将原始JSON作为标签会导致Prometheus高基数问题（每个唯一JSON创建一个新时间序列）。解决方案：

#### 方案A：使用JSON摘要（推荐）
```java
// 在AOP切面中替换为：
String queryHash = DigestUtils.sha256Hex(queryJson); // Apache Commons Codec

Timer.builder("user.query.timer")
    .tags("query_hash", queryHash) // 使用哈希代替原始JSON
    .register(meterRegistry)
    .record(duration, TimeUnit.MILLISECONDS);

// 同时记录原始JSON到日志
log.info("Query executed: hash={}, json={}", queryHash, queryJson);
```

#### 方案B：提取关键字段
```java
// 解析JSON提取关键字段
JsonNode node = new ObjectMapper().readTree(queryJson);
String queryType = node.get("type").asText();

Timer.builder("user.query.timer")
    .tags("query_type", queryType) // 使用有限值域的标签
    .register(meterRegistry)
    .record(duration, TimeUnit.MILLISECONDS);
```

---

### 5. 配置Prometheus拉取数据
在`prometheus.yml`中添加任务：
```yaml
scrape_configs:
  - job_name: 'spring-query-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080'] # 服务地址
```

---

### 6. 验证指标
启动应用后访问：  
`http://localhost:8080/actuator/prometheus`

应能看到类似指标：
```
# HELP user_query_timer_seconds  
# TYPE user_query_timer_seconds summary
user_query_timer_seconds_count{query_hash="a1b2c3...",} 5.0
user_query_timer_seconds_sum{query_hash="a1b2c3...",} 0.45
```

---

### 完整技术栈说明
| 组件 | 作用 |
|-------|------|
| Spring Boot Actuator | 提供监控端点 |
| Micrometer | 指标采集抽象库 |
| Prometheus Registry | 将指标转为Prometheus格式 |
| AOP (AspectJ) | 实现无侵入式指标收集 |
| Prometheus Server | 存储和查询指标 |

---

### 关键注意事项
1. **高基数问题**：避免使用无限值域的标签（如原始JSON）
2. **性能影响**：指标收集应轻量，避免阻塞业务线程
3. **数据安全**：避免记录敏感信息（可添加过滤逻辑）
4. **采样策略**：高频查询可考虑采样记录
5. **存储分离**：原始JSON建议存日志系统（如ELK）

通过以上实现，您可以安全地记录用户查询的详细信息和性能指标，同时保持系统的可观测性和稳定性。