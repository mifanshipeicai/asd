在 Spring Boot 中集成 Spring JDBC 实现多 Dremio 数据源的负载均衡和健康检查，可以通过以下方案实现：

### 1. 添加依赖
```xml
<dependencies>
    <!-- Spring JDBC -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    
    <!-- Dremio JDBC 驱动 -->
    <dependency>
        <groupId>com.dremio</groupId>
        <artifactId>dremio-jdbc-driver</artifactId>
        <version>24.0.0</version> <!-- 使用实际版本 -->
    </dependency>
    
    <!-- 健康检查 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### 2. 配置文件 (`application.yml`)
```yaml
app:
  datasources:
    dremio:
      ds1:
        url: jdbc:dremio:direct=host1:31010;schema=my_schema
        username: user1
        password: pass1
      ds2:
        url: jdbc:dremio:direct=host2:31010;schema=my_schema
        username: user2
        password: pass2

# Actuator 健康检查端点
management:
  endpoint:
    health:
      show-details: always
```

### 3. 核心实现类

#### 3.1 数据源配置类
```java
@Configuration
public class DremioDataSourceConfig {

    @Bean
    @ConfigurationProperties("app.datasources.dremio.ds1")
    public DataSource dremioDataSource1() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("app.datasources.dremio.ds2")
    public DataSource dremioDataSource2() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public LoadBalancedDataSource loadBalancedDataSource(
            @Qualifier("dremioDataSource1") DataSource ds1,
            @Qualifier("dremioDataSource2") DataSource ds2) {
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("ds1", ds1);
        targetDataSources.put("ds2", ds2);
        
        LoadBalancedDataSource routingDataSource = new LoadBalancedDataSource();
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(ds1); // 默认数据源
        
        return routingDataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(@Qualifier("loadBalancedDataSource") DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

#### 3.2 负载均衡数据源路由
```java
public class LoadBalancedDataSource extends AbstractRoutingDataSource {

    private final AtomicInteger counter = new AtomicInteger(0);
    private final Map<Object, DataSource> dataSourceMap = new ConcurrentHashMap<>();
    private final Map<String, Boolean> healthStatus = new ConcurrentHashMap<>();

    @Override
    public void setTargetDataSources(Map<Object, Object> targetDataSources) {
        super.setTargetDataSources(targetDataSources);
        dataSourceMap.clear();
        targetDataSources.forEach((key, value) -> {
            dataSourceMap.put(key, (DataSource) value);
            healthStatus.put(key.toString(), true); // 初始状态健康
        });
    }

    @Override
    protected Object determineCurrentLookupKey() {
        List<String> activeKeys = healthStatus.entrySet().stream()
                .filter(Map.Entry::getValue)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        if (activeKeys.isEmpty()) {
            throw new IllegalStateException("No available Dremio data sources");
        }

        int index = counter.getAndIncrement() % activeKeys.size();
        return activeKeys.get(index);
    }

    // 更新健康状态
    public void updateHealthStatus(String dataSourceKey, boolean isHealthy) {
        healthStatus.put(dataSourceKey, isHealthy);
    }

    // 获取所有数据源状态
    public Map<String, Boolean> getHealthStatus() {
        return new HashMap<>(healthStatus);
    }
}
```

#### 3.3 健康检查定时任务
```java
@Component
@RequiredArgsConstructor
public class DataSourceHealthChecker {

    private final LoadBalancedDataSource routingDataSource;
    private final Map<String, DataSource> dataSourceMap;

    @PostConstruct
    public void init() {
        dataSourceMap = routingDataSource.getDataSourceMap(); // 从路由数据源获取所有DS
    }

    @Scheduled(fixedDelay = 5000) // 每5秒检查一次
    public void checkDataSources() {
        dataSourceMap.forEach((key, dataSource) -> {
            boolean isHealthy = checkConnection(dataSource);
            routingDataSource.updateHealthStatus(key, isHealthy);
        });
    }

    private boolean checkConnection(DataSource dataSource) {
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute("SELECT 1"); // 简单查询验证连接
            return true;
        } catch (SQLException e) {
            return false;
        }
    }
}
```

#### 3.4 集成 Actuator 健康检查
```java
@Component
public class DremioHealthIndicator implements HealthIndicator {

    private final LoadBalancedDataSource routingDataSource;

    public DremioHealthIndicator(LoadBalancedDataSource routingDataSource) {
        this.routingDataSource = routingDataSource;
    }

    @Override
    public Health health() {
        Map<String, Boolean> status = routingDataSource.getHealthStatus();
        boolean allHealthy = status.values().stream().allMatch(Boolean::valueOf);
        
        Health.Builder builder = allHealthy ? 
                Health.up() : Health.down();
        
        status.forEach((key, healthy) -> 
            builder.withDetail(key, healthy ? "UP" : "DOWN")
        );
        
        return builder.build();
    }
}
```

### 4. 使用示例
```java
@RestController
@RequiredArgsConstructor
public class DemoController {

    private final JdbcTemplate jdbcTemplate;

    @GetMapping("/query")
    public List<Map<String, Object>> queryData() {
        return jdbcTemplate.queryForList("SELECT * FROM my_table");
    }
}
```

### 方案说明

1. **负载均衡机制**：
   - 轮询算法通过 `AtomicInteger` 计数器实现
   - 只路由到标记为健康状态的数据源
   - 自动跳过不可用节点

2. **健康检查**：
   - 定时任务每5秒执行一次 `SELECT 1` 验证
   - 动态更新路由状态
   - 通过 `/actuator/health` 端点可视化状态

3. **故障转移**：
   - 当数据源不可用时自动从路由池移除
   - 恢复后自动重新加入路由池
   - 所有数据源宕机时抛出明确异常

4. **扩展性**：
   - 轻松添加更多数据源（只需修改配置）
   - 支持自定义负载均衡策略
   - 可集成更复杂的健康检查逻辑

### 注意事项

1. Dremio JDBC URL 格式：
   ```java
   jdbc:dremio:direct=host:port;schema=your_schema
   ```

2. 建议在配置中增加连接池参数：
   ```yaml
   app.datasources.dremio.ds1:
     hikari:
       connection-timeout: 3000
       max-lifetime: 600000
   ```

3. 生产环境建议：
   - 增加健康检查失败阈值（避免瞬时故障误判）
   - 添加熔断机制（如 Resilience4j）
   - 实现更复杂的负载均衡算法（如加权轮询）

此方案实现了动态负载均衡和自动故障转移，同时通过 Spring Actuator 提供监控接口，满足生产环境高可用要求。