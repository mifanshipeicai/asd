在 Spring Boot WebFlux 中实现批量插入并处理事务回退的分批操作，可以通过 Reactor 的响应式编程模型实现。以下是完整实现方案：

核心思路

1. 批量模式：使用同一个事务 ID 插入所有数据，任一失败则回滚整个事务

2. 回退单条模式：回滚后逐条插入，每条数据使用独立的事务

3. 复用 Token：整个流程使用同一个认证 token

4. 错误处理：记录失败数据，继续处理后续条目

实现代码

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.web.reactive.function.client.WebClient;

public class BatchDataInserter {

    private final WebClient webClient;
    
    public BatchDataInserter(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.build();
    }

    // 主入口方法
    public Flux<InsertionResult> processBatch(List<Data> dataList) {
        return getAuthToken()
            .flatMap(token -> processBatchWithToken(token, dataList))
            .flatMapIterable(result -> result); // 展开批处理结果
    }

    private Mono<List<InsertionResult>> processBatchWithToken(String token, List<Data> dataList) {
        // 1. 获取批量事务ID
        return getTransactionId(token, true)
            .flatMap(transactionId -> {
                // 2. 批量插入所有数据
                Flux<InsertionResult> batchResults = Flux.fromIterable(dataList)
                    .flatMap(data -> 
                        insertData(token, transactionId, data)
                            .map(success -> new InsertionResult(data, success, transactionId))
                            .onErrorReturn(new InsertionResult(data, false, transactionId))
                    );

                // 3. 收集结果并判断是否全部成功
                return batchResults.collectList()
                    .flatMap(results -> {
                        boolean allSuccess = results.stream().allMatch(InsertionResult::isSuccess);
                        
                        if (allSuccess) {
                            // 全部成功 - 提交事务
                            return closeTransaction(token, transactionId)
                                .thenReturn(results);
                        } else {
                            // 部分失败 - 回滚整个事务
                            return rollbackTransaction(token, transactionId)
                                .then(processIndividualItems(token, dataList)) // 进入单条重试
                                .flatMap(individualResults -> 
                                    // 合并两次尝试的结果
                                    Flux.fromIterable(results)
                                        .filter(InsertionResult::isSuccess)
                                        .concatWith(Flux.fromIterable(individualResults))
                                        .collectList()
                                );
                        }
                    });
            });
    }

    // 单条插入模式（每条数据独立事务）
    private Mono<List<InsertionResult>> processIndividualItems(String token, List<Data> dataList) {
        return Flux.fromIterable(dataList)
            .flatMap(data -> 
                getTransactionId(token, false)  // 为每条数据获取新事务ID
                    .flatMap(transactionId -> 
                        insertData(token, transactionId, data)
                            .flatMap(success -> {
                                if (success) {
                                    return closeTransaction(token, transactionId)
                                        .thenReturn(new InsertionResult(data, true, transactionId));
                                } else {
                                    return rollbackTransaction(token, transactionId)
                                        .thenReturn(new InsertionResult(data, false, transactionId));
                                }
                            })
                            .onErrorResume(ex -> 
                                rollbackTransaction(token, transactionId)
                                    .thenReturn(new InsertionResult(data, false, transactionId))
                            )
                    )
            )
            .collectList();
    }

    // --- 第三方API调用方法（根据实际API调整） ---
    private Mono<String> getAuthToken() {
        return webClient.post()
            .uri("/auth")
            .retrieve()
            .bodyToMono(TokenResponse.class)
            .map(TokenResponse::token);
    }

    private Mono<String> getTransactionId(String token, boolean isBatch) {
        return webClient.post()
            .uri("/transactions")
            .header("Authorization", "Bearer " + token)
            .header("X-Batch-Mode", String.valueOf(isBatch))
            .retrieve()
            .bodyToMono(TransactionResponse.class)
            .map(TransactionResponse::transactionId);
    }

    private Mono<Boolean> insertData(String token, String transactionId, Data data) {
        return webClient.post()
            .uri("/data")
            .header("Authorization", "Bearer " + token)
            .header("X-Transaction-Id", transactionId)
            .bodyValue(data)
            .exchangeToMono(response -> {
                if (response.statusCode().is2xxSuccessful()) {
                    return Mono.just(true);
                } else {
                    return response.createException()
                        .flatMap(ex -> Mono.just(false));
                }
            });
    }

    private Mono<Boolean> closeTransaction(String token, String transactionId) {
        return webClient.post()
            .uri("/transactions/" + transactionId + "/commit")
            .header("Authorization", "Bearer " + token)
            .retrieve()
            .bodyToMono(TransactionResult.class)
            .map(TransactionResult::success);
    }

    private Mono<Boolean> rollbackTransaction(String token, String transactionId) {
        return webClient.post()
            .uri("/transactions/" + transactionId + "/rollback")
            .header("Authorization", "Bearer " + token)
            .retrieve()
            .bodyToMono(TransactionResult.class)
            .map(TransactionResult::success);
    }

    // --- 辅助类 ---
    private record TokenResponse(String token) {}
    private record TransactionResponse(String transactionId) {}
    private record TransactionResult(boolean success) {}
    
    public static class InsertionResult {
        private final Data data;
        private final boolean success;
        private final String transactionId;

        // 构造函数、getters 等
    }
}


关键设计说明

1. 事务模式标识

  ◦ 在 getTransactionId 方法中添加 X-Batch-Mode 头，让第三方区分批量/独立事务

  ◦ 批量模式使用同一个事务ID，单条模式每次获取新事务ID

2. 错误恢复流程

graph TD
  A[开始批量处理] --> B[获取事务ID]
  B --> C{所有插入成功?}
  C -->|是| D[提交事务]
  C -->|否| E[回滚批量事务]
  E --> F[逐条插入数据]
  F -->|获取新事务ID| G[单条插入]
  G -->|成功| H[提交单条事务]
  G -->|失败| I[回滚单条事务]
  H --> J[记录结果]
  I --> J


3. 结果合并策略

  ◦ 批量成功的数据：保留第一次插入结果

  ◦ 批量失败的数据：在单条重试中更新结果

  ◦ 最终返回合并后的结果列表

4. 弹性控制

  ◦ flatMap 用于并发控制（可添加参数控制并发量）

  ◦ onErrorResume 确保单条失败不中断整个流程

  ◦ WebClient 的响应处理考虑各种 HTTP 状态

使用示例

@RestController
public class DataController {

    private final BatchDataInserter inserter;

    // 批量插入入口
    @PostMapping("/batch-insert")
    public Flux<BatchDataInserter.InsertionResult> batchInsert(@RequestBody List<Data> data) {
        return inserter.processBatch(data);
    }
}


注意事项

1. API 适配

  ◦ 替换方法中的 URI 和响应体结构为实际第三方 API

  ◦ 根据 API 认证要求调整请求头

2. 并发控制

  ◦ 在 flatMap 中添加参数控制并发量（如 .flatMap(data -> ..., 5) 限制5并发）

  ◦ 批量操作中考虑使用 buffer 分片处理超大列表

3. Token 管理

  ◦ 当前实现每个批次获取新 token，如需复用可添加缓存

  ◦ 考虑添加 token 刷新机制处理过期

4. 监控增强

  ◦ 添加日志记录各阶段耗时

  ◦ 集成 Metrics 监控成功/失败率

  ◦ 使用 doOnError 记录详细错误信息

此实现确保了在响应式环境下正确处理批量事务和失败重试，同时保持系统的弹性和可观察性。