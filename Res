为了去除List中重复key的Map，并保留最新加入的那个，可以按照以下步骤实现：

1. **逆序遍历原List**：这样可以确保先访问到每个key最后一次出现的元素。
2. **使用Set记录已处理的key**：当第一次遇到某个key时（即逆序中首次出现，原List中最后一次出现），将其对应的Map加入结果列表。
3. **反转结果列表**：恢复元素在原List中的最后一次出现的顺序。

以下是Java代码实现：

```java
import java.util.*;

public class RemoveDuplicateMaps {

    public static List<Map<String, Object>> removeDuplicates(List<Map<String, Object>> list) {
        Set<String> seen = new HashSet<>();
        List<Map<String, Object>> result = new ArrayList<>();

        // 逆序遍历原List，确保保留最后一次出现的元素
        for (int i = list.size() - 1; i >= 0; i--) {
            Map<String, Object> map = list.get(i);
            String key = map.keySet().iterator().next();
            if (seen.add(key)) { // 如果key未被添加过，则加入结果列表
                result.add(map);
            }
        }

        // 反转结果以保持原List中最后一次出现的顺序
        Collections.reverse(result);
        return result;
    }

    public static void main(String[] args) {
        // 示例测试
        List<Map<String, Object>> list = new ArrayList<>();
        addEntry(list, "A", 1);
        addEntry(list, "B", 2);
        addEntry(list, "A", 3);
        addEntry(list, "C", 4);
        addEntry(list, "B", 5);

        List<Map<String, Object>> result = removeDuplicates(list);
        for (Map<String, Object> map : result) {
            System.out.println(map);
        }
        // 输出：
        // {A=3}
        // {C=4}
        // {B=5}
    }

    private static void addEntry(List<Map<String, Object>> list, String key, Object value) {
        Map<String, Object> map = new HashMap<>();
        map.put(key, value);
        list.add(map);
    }
}
```

**步骤解释**：
1. **逆序遍历**：从List末尾开始遍历，确保每个key第一次被遇到时是其在原List中最后一次出现的位置。
2. **使用Set去重**：通过`seen.add(key)`判断是否已处理过该key，未处理则添加到结果列表。
3. **反转结果**：由于逆序添加导致结果顺序与原List相反，通过`Collections.reverse(result)`恢复正确的顺序。

该方法确保每个key保留最新的Map，且顺序与原List中最后一次出现的顺序一致。